[[rolling-upgrades]]
=== 滚动升级

滚动升级允许 Elasticsearch 集群一次升级一个节点, 而对于终端用户来说没有停机时间.在同一个集群中运行
多个版本的 Elasticsearch 对于超出升级所需的任何长度的时间都是不支持的, 因为分片不会从最近的版本复制到
旧的版本.

查阅这个 <<setup-upgrade,表格>> 来检查一下你的 Elasticsearch 版本是否支持滚动升级.

要执行滚动升级:

==== 第 1 步: 禁用分片分配

当你关闭节点的时候, 当前节点上的分配进程会立刻将分片复制到集群中另外的节点上, 这样就造成了大量的 I/O 浪费. 可以通过在节点关闭之前禁用分配来避免这种情况:

[source,js]
--------------------------------------------------
PUT /_cluster/settings
{
  "transient": {
    "cluster.routing.allocation.enable": "none"
  }
}
--------------------------------------------------
// AUTOSENSE

==== 第 2 步: 停止不必要的索引并执行一次同步的刷新 (可选的)

你可以很愉快的在升级期间继续索引. 然而, 如果你临时停止不必要的索引并发起一
次 <<indices-synced-flush, 同步刷新>> 请求, 分片恢复将会快很多:

[source,js]
--------------------------------------------------
POST /_flush/synced
--------------------------------------------------
// AUTOSENSE

一次同步刷新请求是 ``尽力而为'' 的操作, 如果有任何悬而未决的索引操作它将会失败, 但是如有必要多次发起这个请求是很安全的.

[[upgrade-node]]
==== 第 3 步: 停止并升级单个节点

开始升级 *之前* 先关闭集群中的一个节点.

[TIP]
================================================

当使用 zip 或 tar 包的时候, `config`, `data`, `logs` 以及
`plugins` 目录默认放置在 Elasticsearch 安装目录下.

比较好的做法是将这些目录放置在一个不同的位置, 这样在升级 Elasticsearch 时就不会删掉它们. 这些自定义的路径
可以使用 `path.config` 和 `path.data` 设置来 <<paths,配置>>.

对于每个操作系统来说, Debian 和 RPM 包将这些目录放置在 <<setup-dir-layout,合适的位置>> .

================================================

使用 <<setup-repositories,Debian 或 RPM>> 包进行升级:

*   使用 `rpm` 或 `dpkg` 来安装新的包. 所有的文件都应该在它们提供的路径中并且配置文件不会被覆盖, and config files should not be
    overwritten.

使用 zip 或 tar 包进行升级:

*   加压 zip 或 tar 包到一个新的目录, 确保你不会覆盖 `config` 或 `data` 目录.

*   要么将 `config` 目录中的文件从原来的安装目录拷贝到新的安装目录, 要么在命令行使用 `--path.config` 选项来指向一个外部的配置目录.

*   要么将 `data` 目录中的文件从原来的安装目录拷贝到新的安装目录, 要么使用 `path.data` 设置在 `config/elasticsearch.yml` 文件中配置数据目录.

==== 第 4 步: 启动升级后的节点

启动刚升级后的节点并通过检查日志文件或是检查下面请求的输出来确定它加入到集群中:

[source,sh]
--------------------------------------------------
GET _cat/nodes
--------------------------------------------------
// AUTOSENSE

==== 第 5 步: 重新启用分片分配

一旦节点加入到集群中, 使用这个节点来重新启用分片分配:

[source,js]
--------------------------------------------------
PUT /_cluster/settings
{
  "transient": {
    "cluster.routing.allocation.enable": "all"
  }
}
--------------------------------------------------
// AUTOSENSE

==== 第 6 步: 等待节点恢复

在升级下个节点之前你应该等待集群完成分片分配. 你可以使用 <<cat-health,`_cat/health`>> 请求来检查进度:

[source,sh]
--------------------------------------------------
GET _cat/health
--------------------------------------------------
// AUTOSENSE

等待 `status` 这一列从 `yellow` 变成 `green`. `green` 状态意味着所有主分片和复制分片都已经被分配了.

[IMPORTANT]
====================================================
在滚动升级期间, 分配到使用高版本的节点上的主分片不会让它们的副本分配到使用低版本的节点上, 因为新的版本可能有老版本无法理解的不同的数据格式.

如果没有办法将复制分片分配到使用高版本的节点上 -- 例如, 如果集群中只有一个使用高版本的节点 -- 那么复制分片仍然不会被分配并且集群健康仍然停留在 `yellow` 状态.

在这种情况下, 在继续进行之前确保没有初始化或迁移分片 (`init` 和 `relo` 列) .

只要另一个节点升级完毕, 副本就会被分配并且集群健康会达到 `green` 状态.

====================================================

没有进行 <<indices-synced-flush,同步刷新>> 的分片需要一些时间来恢复. 每个分片的恢复状态可以使用 <<cat-recovery,`_cat/recovery`>> 请求监控到:

[source,sh]
--------------------------------------------------
GET _cat/recovery
--------------------------------------------------
// AUTOSENSE

如果你停止了索引, 那么只要节点恢复完成你就可以继续索引.

==== 第 7 步: 重复

当集群稳定并且节点恢复之后, 对所有剩余节点重复上述步骤.
